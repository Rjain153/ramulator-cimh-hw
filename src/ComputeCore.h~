#ifndef __COMPUTECORE_H
#define __COMPUTECORE_H

#include <list>
#include <deque>
#include <string>
#include <vector>
#include <map>

using namespace std;

namespace ramulator {

class ComputeCore {
 public:
    /* Member variables */
    long clk = 0;

    bool enqueue(Request& req) {
      // @rajat: Handle the reception of a new request
      // 1. See whether we need to introduce a queue for the incoming requests
      // 2. There will be push back from the memory controller to Slave UXI switches and that
      //    will be propagated to MasterUxiSwitch
 
      req.arrive = clk;
      req.depart = clk+1;

    }

    void compute( uint64_t emb_row_addr, uint64_t pool_result_addr ) {
      int data = read(emb_row_addr); // read the embedding row
      int partial_res = read(pool_result_addr);
      
      // perform the pooling operation
      partial_res = partial_res + data;

      // write back the result
      write(pool_result_addr, partial_res);
    }
    
    void tick() {
      clk++;
      
      //@rajat: Fill in the logic
      // Handle the processing of an NMP request if pending
    }

    void finish() {
      // @rajat: Fill in the logic
    }

};// class ComputeCore
  


  
}  // namespace ramulator
#endif //__COMPUTECORE_H
